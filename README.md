# 2025_React
## 실행결과
##
## 각 주차의 class에는 수업내용과 결과물을, report에는 해당 주차 과제물을 업로드 해뒀습니다. 
##
## 1주차
#### 1.1 MPA
![image](https://github.com/user-attachments/assets/32292024-0c5f-47cf-84ee-c85d2998a4a3)
#### 1.2 SPA
![image](https://github.com/user-attachments/assets/95bb9d97-8111-4409-98a7-943caf4f8642)
##### 위에 있는 1주차 파일들은 week1에 readme에 정리해뒀습니다.

## 2주차
#### 2.1 curd.html
![image](https://github.com/user-attachments/assets/106392e9-fee3-421c-a787-9410c91320e4)
#### 2.2 Button
![리포트에 넣을까](https://github.com/user-attachments/assets/85ca1ff7-f450-4880-8fae-bf6f4289af96)
#### 2.3 Library
![image](https://github.com/user-attachments/assets/e39d3723-c4f2-4cff-8c05-d0c61a3e0ea0)
#### 2.4 자기소개 report 입니다
![image](https://github.com/user-attachments/assets/77643e09-8dea-4b5b-9a7a-4e518fc7f69d)
##### crud.html을 수정하여 파일을 작성하고, HTML skeleton 파일에서 자바스크립트만을 이용해 동일한 페이지를 구현하였습니다.

## 3주차
#### 3.1 clock_123 & binary clock
![clock](https://github.com/user-attachments/assets/dab39341-a729-4a82-b4bf-4868ff12f596)
####
![clock2](https://github.com/user-attachments/assets/84d69826-4564-4a5b-a8a7-789b65a48145)
####
![bclock](https://github.com/user-attachments/assets/22edc5e9-062a-4cf2-bc58-d191b8b25751)
####
![clock3](https://github.com/user-attachments/assets/2a800b6b-1634-4a9a-be39-91dce1aa0ca4)
#### 3.2 댓글 컴포넌트
![image](https://github.com/user-attachments/assets/fcacd629-baf5-43a2-9f51-58bd406311dd)

##### 댓글 컴포넌트는 week3에 업로드 해두었습니다.

## 4주차
#### 4.1 실행결과
![화면 캡처 2025-03-26 141925](https://github.com/user-attachments/assets/c2803763-33b5-4599-86a1-ed02c66f5c05)

#### 4.2 부산 소개 웹페이지
![image](https://github.com/user-attachments/assets/8b0c0300-4dbb-46b8-b655-aa7799d23544)

## 5주차
#### 5.1 AI 활용 실행결과
![image](https://github.com/user-attachments/assets/d0a2fde3-f150-4f98-9019-2381e96f1a38)

#### 5.2 다른 버전 
![image](https://github.com/user-attachments/assets/a341e274-b3a4-47ba-abd5-610d98c40c7f)

## 5주차 수업내용 정리

# 🧠 인공지능 AI 

| 번호 | 주제 | 주요 내용 | 이모지 |
|------|------|-----------|--------|
| 1️⃣ | **인공지능의 이해** | - AI의 개념과 발전<br>- 기계학습, 딥러닝 등 주요 기술<br>- 다양한 산업에서의 활용 사례 | 🧠🌍 |
| 2️⃣ | **LLM의 이해와 기초 활용** | - 대규모 언어 모델(LLM) 이해<br>- GPT의 작동 원리<br>- 프롬프트 설계 및 실전 활용 | 📚🛠️ |
| 3️⃣ | **챗봇 AI별 특징 알아보기** | - 챗GPT, Bing, Bard, Claude 등 비교<br>- 각 챗봇의 강점과 활용 예<br>- 목적에 따른 추천 | 💬🎯 |
| 4️⃣ | **AI와 실무 문서 작성하기** | - 보고서, 회의록, 기획서 자동 작성<br>- 스타일 조정 및 자동 요약<br>- 실무 활용 예시 | 📄✍️ |
| 5️⃣ | **검색의 신세계, AI 검색** | - Perplexity 등 AI 검색툴 소개<br>- 출처 기반 답변 생성<br>- 실시간 정보와 전문 검색 | 🔎📁 |
| 6️⃣ | **시각화부터 PPT까지 AI로 뚝딱** | - 데이터 분석 → 차트 자동 생성<br>- draw.io 다이어그램 제작<br>- 한글 깨짐 해결 팁 | 📈🖌️ |
| 7️⃣ | **AI로 이미지 생성하기** | - DALL·E 3 등 이미지 생성 툴<br>- 스타일, 색상, 텍스처 조정<br>- 클립아트부터 실사까지 가능 | 🎨🖼️ |
| 8️⃣ | **무료 영상 생성** | - 프롬프트로 영상 제작<br>- 카메라 앵글, 효과 설정<br>- 크레딧 기반 / 무료 체험 | 🎬🎥 |
| 9️⃣ | **오디오 AI 활용** | - 다양한 보이스 캐릭터 제공<br>- 음악, 가사 생성 기능<br>- 문단 단위 편집 가능 | 🔊🎶 |
| 🔟 | **반복되는 업무는 챗봇에게** | - 회의록 요약 자동화<br>- 연구자료 요약 GPT<br>- 챗봇 제작 도구 소개 | 🤖📝 |

## 6주차
#### 6.1 Counter 비교
![image](https://github.com/user-attachments/assets/d6414e80-b313-43f2-9f4d-974e85d6d1f1)
![image](https://github.com/user-attachments/assets/55862c25-24e0-4976-95d6-6b68884dc87c)
---
#### 6.2 Area와 기능 추가
![image](https://github.com/user-attachments/assets/8728c860-ebe8-40ef-bf54-6e10403b6aaf)
![image](https://github.com/user-attachments/assets/d4beed4d-53ba-428b-81d2-51461148e5c8)
---
#### 6.3 부산 청년 정책 리포트 
![image](https://github.com/user-attachments/assets/ae884628-8d22-4bcc-9027-d4d8cb672adf)



## 6주차 수업내용 정리
---

# ⚛️ 리액트 훅(Hooks) 

| 항목 | 설명 | 예시/비고 | 이모지 |
|------|------|------------|--------|
| **🔹 훅이란?** | 함수형 컴포넌트에서도 상태(state)나 생명주기 기능을 사용할 수 있게 해주는 기능 | 클래스 컴포넌트의 `this.state`, `setState` 없이 사용 가능 | 📝 |
| **🔸 useState** | 상태값을 관리하는 훅 | `[state, setState] = useState(initialValue)` | 📦 |
| **🔸 useEffect** | 사이드 이펙트를 처리 (예: API 호출, DOM 조작 등) | `useEffect(() => { ... }, [deps])`<br>- mount/update 구분<br>- cleanup 함수는 unmount 시 실행 | ⚙️ |
| **🔸 useMemo** | 연산량이 많은 계산의 결과를 메모이제이션 | `useMemo(() => calc(), [deps])`<br>렌더링 중 실행되는 코드만 허용 | 🧮 |
| **🔸 useCallback** | 함수 자체를 메모이제이션하여 참조 변경 방지 | `useCallback(() => fn(), [deps])`<br>자식 컴포넌트 불필요 렌더 방지 | 🔁 |
| **🔸 useRef** | DOM 접근 또는 값 저장용으로 활용<br>렌더링과 무관 | `const ref = useRef(null)`<br>`ref.current`로 접근 | 🔍 |
| **🧾 훅의 규칙** | - 최상위 레벨에서만 호출<br>- 조건문/반복문 내부 호출 ❌<br>- `use`로 시작해야 함 | 리액트 함수 컴포넌트 또는 커스텀 훅 내에서만 사용 | 📏 |
| **🛠️ 커스텀 훅** | 재사용 가능한 로직을 함수화<br>이름은 반드시 `use`로 시작 | 예: `useCounter()`, `useUserStatus()` 등 | 🧩 |
| **🧪 실습 예시** | - `useCounter.jsx`: 카운터 훅<br>- `Accommodate.jsx`: 조건에 따른 렌더링<br>- `index.js`: 실행 코드 | `npm start`로 실행 | 🧪 |

---


📌 **기억할 것!**
- `useEffect`에서 의존성 배열이 없는 경우, **매번 렌더링마다 실행**
- 의존성 배열이 있는 경우, **배열 내부 값이 변경될 때만 실행**
- `useMemo`, `useCallback`은 최적화 용도로만! 남발 ❌


---

## 🔹 Component State

### ✔️ State란?
- 컴포넌트 내부에서 관리되는 데이터.
- 사용자와의 상호작용, 시간 경과, 네트워크 응답 등에 따라 변경됨.
- 컴포넌트의 동작과 UI에 직접적인 영향을 줌.

### ✔️ State를 사용하는 이유
- 사용자 입력, 이벤트, API 호출 등에 따라 UI를 동적으로 변경할 수 있음.
- React에서는 UI = f(state) 형태로 구성됨.
- State가 바뀌면 React는 자동으로 다시 렌더링하여 UI를 최신 상태로 유지함.

---

## 🔹 Blocking vs Synchronous 

### ✔️ 개념 설명

| 구분             | 설명 |
|------------------|------|
| **Blocking**     | 하나의 작업이 끝나기 전까지 다음 작업을 시작하지 못하는 방식. 실행 흐름이 "막히는" 특성이 있음. |
| **Non-Blocking** | 작업을 요청만 하고, 결과가 준비되면 알림을 받는 방식. 나머지 흐름은 그대로 진행됨. |
| **Synchronous**  | 요청 → 응답 순서가 보장되는 처리 방식. 응답이 오기 전까지 기다림. |
| **Asynchronous** | 요청 후 바로 다음 작업을 실행하고, 결과는 나중에 별도로 처리함. 비동기 콜백 또는 Promise/async-await 구조로 주로 구현됨. |

### ✔️ 관계 이해
- Blocking & Synchronous: 전통적인 동기 호출 방식. 함수 호출 → 응답까지 대기.
- Non-Blocking & Asynchronous: 현대 웹에서 많이 사용하는 비동기 호출. UI 멈춤 없이 처리 가능.

---

## 🔹 Component 구성과 종류

### ✔️ Class Component
- ES6 클래스 기반의 컴포넌트.
- `render()` 메서드 필수.
- `this.state`와 `this.setState()`를 사용해 상태 관리.
- 생명주기 메서드 사용 가능 (e.g., `componentDidMount()`)

### ✔️ Function Component
- 함수로 정의된 컴포넌트.
- React Hooks(`useState`, `useEffect` 등) 사용으로 상태 관리 가능.
- 간결하고 가독성이 좋음.

---

## 🔹 Event Handling

### ✔️ 이벤트 핸들링 방식
- JSX에서는 camelCase로 이벤트 이름을 작성.
- 예: `onClick`, `onChange`, `onSubmit`
- 함수 참조를 중괄호 `{}` 안에 작성.

### ✔️ 이벤트 객체 사용
- 이벤트 핸들러에 `event` 객체가 자동 전달됨.
- `event.preventDefault()`로 기본 동작 막기 가능.

---

## 🔹 Component Life Cycle (생명주기)

> 클래스형 컴포넌트에서만 사용됨.

| 단계           | 메서드                  | 설명                           |
|----------------|--------------------------|--------------------------------|
| Mounting       | `constructor`, `render`, `componentDidMount` | 컴포넌트가 처음 DOM에 삽입될 때 |
| Updating       | `shouldComponentUpdate`, `componentDidUpdate` | props 또는 state 변경 시        |
| Unmounting     | `componentWillUnmount`   | 컴포넌트가 DOM에서 제거될 때   |

---

## 🔹 카멜표기법 vs 파스칼표기법

| 표기법       | 예시             | 사용 용도                             |
|--------------|------------------|----------------------------------------|
| 카멜 표기법  | `myVariable`     | 변수명, 함수명, 이벤트 핸들러 등       |
| 파스칼 표기법| `MyComponent`    | 컴포넌트 이름, 클래스 이름 등          |

- 카멜 표기법 (Camel Case) 첫 번째 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 시작합니다. 
- 파스칼 표기법 (Pascal Case): 모든 단어의 첫 글자를 대문자로 시작하고, 단어 사이에는 공백이나 특수 문자가 없이 연결합니다.

---

## 🧩 React Hook이란?

- 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 쓸 수 있게 해주는 기능 (v16.8부터 도입)
- 클래스형 컴포넌트의 단점을 보완하여 함수형 컴포넌트를 강화

## ⚙️ 대표 Hook들

| 종류 | Hook |
|------|------|
| 상태 관리 | `useState`, `useReducer` |
| 참조 | `useRef`, `useImperativeHandle` |
| 효과 처리 | `useEffect`, `useLayoutEffect`, `useInsertionEffect` |
| 성능 최적화 | `useMemo`, `useCallback`, `useTransition`, `useDeferredValue` |
| 기타 | `useId`, `useDebugValue`, `useSyncExternalStore` |
| 사용자 정의 | Custom Hook |

## ✅ Hook 사용 규칙

- **최상위**에서만 호출 (조건문, 반복문 ❌)
- **React 함수 컴포넌트** 또는 **Custom Hook** 안에서만 호출

## 🧠 useState 기본

```js
const [state, setState] = useState(initialValue)
```

- 상태 값을 선언하고 수정 가능
- `setState`는 렌더링을 트리거함

### 예제

```js
const [count, setCount] = useState(0);

function increment() {
  setCount(count + 1);
}
```

### 이전 상태 기준 업데이트 (💡주의사항)

```js
setCount(prev => prev + 1); // 안전하게 여러 번 호출 가능
```

## 📝 객체 & 배열 상태 업데이트

- 기존 객체/배열을 직접 수정 ❌  
- 항상 **새로운 객체/배열**을 만들어야 함

```js
setForm({ ...form, name: 'Taylor' });
setTodos([...todos, newTodo]);
```

## 🧪 주의사항 (Troubleshooting)

- 상태 변경 후 즉시 값 반영 ❌ → 다음 렌더링에 적용됨
- `setState(someFunction)` 시 함수 실행됨 → `() => someFunction`으로 감싸야 저장됨
- Strict Mode에서는 초기화 함수와 updater 함수가 **2번 실행됨**

## 📌 활용 예시

- **Form 관리**, **Checkbox 상태**, **Todo 리스트 관리**, **객체/배열 중첩 업데이트**
- `useImmer`로 복잡한 상태 관리 간단화 가능

---
















