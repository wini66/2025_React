# 2025_React
## 실행결과
##
## 각 주차의 class에는 수업내용과 결과물을, report에는 해당 주차 과제물을 업로드 해뒀습니다. 
##
## 1주차
#### 1.1 MPA
![image](https://github.com/user-attachments/assets/32292024-0c5f-47cf-84ee-c85d2998a4a3)
#### 1.2 SPA
![image](https://github.com/user-attachments/assets/95bb9d97-8111-4409-98a7-943caf4f8642)
##### 위에 있는 1주차 파일들은 week1에 readme에 정리해뒀습니다.

## 2주차
#### 2.1 curd.html
![image](https://github.com/user-attachments/assets/106392e9-fee3-421c-a787-9410c91320e4)
#### 2.2 Button
![리포트에 넣을까](https://github.com/user-attachments/assets/85ca1ff7-f450-4880-8fae-bf6f4289af96)
#### 2.3 Library
![image](https://github.com/user-attachments/assets/e39d3723-c4f2-4cff-8c05-d0c61a3e0ea0)
#### 2.4 자기소개 report 입니다
![image](https://github.com/user-attachments/assets/77643e09-8dea-4b5b-9a7a-4e518fc7f69d)
##### crud.html을 수정하여 파일을 작성하고, HTML skeleton 파일에서 자바스크립트만을 이용해 동일한 페이지를 구현하였습니다.

## 3주차
#### 3.1 clock_123 & binary clock
![clock](https://github.com/user-attachments/assets/dab39341-a729-4a82-b4bf-4868ff12f596)
####
![clock2](https://github.com/user-attachments/assets/84d69826-4564-4a5b-a8a7-789b65a48145)
####
![bclock](https://github.com/user-attachments/assets/22edc5e9-062a-4cf2-bc58-d191b8b25751)
####
![clock3](https://github.com/user-attachments/assets/2a800b6b-1634-4a9a-be39-91dce1aa0ca4)
#### 3.2 댓글 컴포넌트
![image](https://github.com/user-attachments/assets/fcacd629-baf5-43a2-9f51-58bd406311dd)

##### 댓글 컴포넌트는 week3에 업로드 해두었습니다.

## 4주차
#### 4.1 실행결과
![화면 캡처 2025-03-26 141925](https://github.com/user-attachments/assets/c2803763-33b5-4599-86a1-ed02c66f5c05)

#### 4.2 부산 소개 웹페이지
![image](https://github.com/user-attachments/assets/8b0c0300-4dbb-46b8-b655-aa7799d23544)

## 5주차
#### 5.1 AI 활용 실행결과
![image](https://github.com/user-attachments/assets/d0a2fde3-f150-4f98-9019-2381e96f1a38)

#### 5.2 다른 버전 
![image](https://github.com/user-attachments/assets/a341e274-b3a4-47ba-abd5-610d98c40c7f)

## 5주차 수업내용 정리

# 🧠 인공지능 AI 

| 번호 | 주제 | 주요 내용 | 이모지 |
|------|------|-----------|--------|
| 1️⃣ | **인공지능의 이해** | - AI의 개념과 발전<br>- 기계학습, 딥러닝 등 주요 기술<br>- 다양한 산업에서의 활용 사례 | 🧠🌍 |
| 2️⃣ | **LLM의 이해와 기초 활용** | - 대규모 언어 모델(LLM) 이해<br>- GPT의 작동 원리<br>- 프롬프트 설계 및 실전 활용 | 📚🛠️ |
| 3️⃣ | **챗봇 AI별 특징 알아보기** | - 챗GPT, Bing, Bard, Claude 등 비교<br>- 각 챗봇의 강점과 활용 예<br>- 목적에 따른 추천 | 💬🎯 |
| 4️⃣ | **AI와 실무 문서 작성하기** | - 보고서, 회의록, 기획서 자동 작성<br>- 스타일 조정 및 자동 요약<br>- 실무 활용 예시 | 📄✍️ |
| 5️⃣ | **검색의 신세계, AI 검색** | - Perplexity 등 AI 검색툴 소개<br>- 출처 기반 답변 생성<br>- 실시간 정보와 전문 검색 | 🔎📁 |
| 6️⃣ | **시각화부터 PPT까지 AI로 뚝딱** | - 데이터 분석 → 차트 자동 생성<br>- draw.io 다이어그램 제작<br>- 한글 깨짐 해결 팁 | 📈🖌️ |
| 7️⃣ | **AI로 이미지 생성하기** | - DALL·E 3 등 이미지 생성 툴<br>- 스타일, 색상, 텍스처 조정<br>- 클립아트부터 실사까지 가능 | 🎨🖼️ |
| 8️⃣ | **무료 영상 생성** | - 프롬프트로 영상 제작<br>- 카메라 앵글, 효과 설정<br>- 크레딧 기반 / 무료 체험 | 🎬🎥 |
| 9️⃣ | **오디오 AI 활용** | - 다양한 보이스 캐릭터 제공<br>- 음악, 가사 생성 기능<br>- 문단 단위 편집 가능 | 🔊🎶 |
| 🔟 | **반복되는 업무는 챗봇에게** | - 회의록 요약 자동화<br>- 연구자료 요약 GPT<br>- 챗봇 제작 도구 소개 | 🤖📝 |

## 6주차
#### 6.1 Counter 비교
![image](https://github.com/user-attachments/assets/d6414e80-b313-43f2-9f4d-974e85d6d1f1)
![image](https://github.com/user-attachments/assets/55862c25-24e0-4976-95d6-6b68884dc87c)
---
#### 6.2 Area와 기능 추가
![image](https://github.com/user-attachments/assets/8728c860-ebe8-40ef-bf54-6e10403b6aaf)
![image](https://github.com/user-attachments/assets/d4beed4d-53ba-428b-81d2-51461148e5c8)
---
#### 6.3 부산 청년 정책 리포트 
![image](https://github.com/user-attachments/assets/ae884628-8d22-4bcc-9027-d4d8cb672adf)



## 6주차 수업내용 정리
---

# ⚛️ 리액트 훅(Hooks) 

| 항목 | 설명 | 예시/비고 | 이모지 |
|------|------|------------|--------|
| **🔹 훅이란?** | 함수형 컴포넌트에서도 상태(state)나 생명주기 기능을 사용할 수 있게 해주는 기능 | 클래스 컴포넌트의 `this.state`, `setState` 없이 사용 가능 | 📝 |
| **🔸 useState** | 상태값을 관리하는 훅 | `[state, setState] = useState(initialValue)` | 📦 |
| **🔸 useEffect** | 사이드 이펙트를 처리 (예: API 호출, DOM 조작 등) | `useEffect(() => { ... }, [deps])`<br>- mount/update 구분<br>- cleanup 함수는 unmount 시 실행 | ⚙️ |
| **🔸 useMemo** | 연산량이 많은 계산의 결과를 메모이제이션 | `useMemo(() => calc(), [deps])`<br>렌더링 중 실행되는 코드만 허용 | 🧮 |
| **🔸 useCallback** | 함수 자체를 메모이제이션하여 참조 변경 방지 | `useCallback(() => fn(), [deps])`<br>자식 컴포넌트 불필요 렌더 방지 | 🔁 |
| **🔸 useRef** | DOM 접근 또는 값 저장용으로 활용<br>렌더링과 무관 | `const ref = useRef(null)`<br>`ref.current`로 접근 | 🔍 |
| **🧾 훅의 규칙** | - 최상위 레벨에서만 호출<br>- 조건문/반복문 내부 호출 ❌<br>- `use`로 시작해야 함 | 리액트 함수 컴포넌트 또는 커스텀 훅 내에서만 사용 | 📏 |
| **🛠️ 커스텀 훅** | 재사용 가능한 로직을 함수화<br>이름은 반드시 `use`로 시작 | 예: `useCounter()`, `useUserStatus()` 등 | 🧩 |
| **🧪 실습 예시** | - `useCounter.jsx`: 카운터 훅<br>- `Accommodate.jsx`: 조건에 따른 렌더링<br>- `index.js`: 실행 코드 | `npm start`로 실행 | 🧪 |

---


📌 **기억할 것!**
- `useEffect`에서 의존성 배열이 없는 경우, **매번 렌더링마다 실행**
- 의존성 배열이 있는 경우, **배열 내부 값이 변경될 때만 실행**
- `useMemo`, `useCallback`은 최적화 용도로만! 남발 ❌


---

## 🔹 Component State

### ✔️ State란?
- 컴포넌트 내부에서 관리되는 데이터.
- 사용자와의 상호작용, 시간 경과, 네트워크 응답 등에 따라 변경됨.
- 컴포넌트의 동작과 UI에 직접적인 영향을 줌.

### ✔️ State를 사용하는 이유
- 사용자 입력, 이벤트, API 호출 등에 따라 UI를 동적으로 변경할 수 있음.
- React에서는 UI = f(state) 형태로 구성됨.
- State가 바뀌면 React는 자동으로 다시 렌더링하여 UI를 최신 상태로 유지함.

---

## 🔹 Blocking vs Synchronous 

### ✔️ 개념 설명

| 구분             | 설명 |
|------------------|------|
| **Blocking**     | 하나의 작업이 끝나기 전까지 다음 작업을 시작하지 못하는 방식. 실행 흐름이 "막히는" 특성이 있음. |
| **Non-Blocking** | 작업을 요청만 하고, 결과가 준비되면 알림을 받는 방식. 나머지 흐름은 그대로 진행됨. |
| **Synchronous**  | 요청 → 응답 순서가 보장되는 처리 방식. 응답이 오기 전까지 기다림. |
| **Asynchronous** | 요청 후 바로 다음 작업을 실행하고, 결과는 나중에 별도로 처리함. 비동기 콜백 또는 Promise/async-await 구조로 주로 구현됨. |

### ✔️ 관계 이해
- Blocking & Synchronous: 전통적인 동기 호출 방식. 함수 호출 → 응답까지 대기.
- Non-Blocking & Asynchronous: 현대 웹에서 많이 사용하는 비동기 호출. UI 멈춤 없이 처리 가능.

---

## 🔹 Component 구성과 종류

### ✔️ Class Component
- ES6 클래스 기반의 컴포넌트.
- `render()` 메서드 필수.
- `this.state`와 `this.setState()`를 사용해 상태 관리.
- 생명주기 메서드 사용 가능 (e.g., `componentDidMount()`)

### ✔️ Function Component
- 함수로 정의된 컴포넌트.
- React Hooks(`useState`, `useEffect` 등) 사용으로 상태 관리 가능.
- 간결하고 가독성이 좋음.

---

## 🔹 Event Handling

### ✔️ 이벤트 핸들링 방식
- JSX에서는 camelCase로 이벤트 이름을 작성.
- 예: `onClick`, `onChange`, `onSubmit`
- 함수 참조를 중괄호 `{}` 안에 작성.

### ✔️ 이벤트 객체 사용
- 이벤트 핸들러에 `event` 객체가 자동 전달됨.
- `event.preventDefault()`로 기본 동작 막기 가능.

---

## 🔹 Component Life Cycle (생명주기)

> 클래스형 컴포넌트에서만 사용됨.

| 단계           | 메서드                  | 설명                           |
|----------------|--------------------------|--------------------------------|
| Mounting       | `constructor`, `render`, `componentDidMount` | 컴포넌트가 처음 DOM에 삽입될 때 |
| Updating       | `shouldComponentUpdate`, `componentDidUpdate` | props 또는 state 변경 시        |
| Unmounting     | `componentWillUnmount`   | 컴포넌트가 DOM에서 제거될 때   |

---

## 🔹 카멜표기법 vs 파스칼표기법

| 표기법       | 예시             | 사용 용도                             |
|--------------|------------------|----------------------------------------|
| 카멜 표기법  | `myVariable`     | 변수명, 함수명, 이벤트 핸들러 등       |
| 파스칼 표기법| `MyComponent`    | 컴포넌트 이름, 클래스 이름 등          |

- 카멜 표기법 (Camel Case) 첫 번째 단어는 소문자로 시작하고, 이후 단어의 첫 글자는 대문자로 시작합니다. 
- 파스칼 표기법 (Pascal Case): 모든 단어의 첫 글자를 대문자로 시작하고, 단어 사이에는 공백이나 특수 문자가 없이 연결합니다.

---

## 🧩 React Hook이란?

- 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 쓸 수 있게 해주는 기능 (v16.8부터 도입)
- 클래스형 컴포넌트의 단점을 보완하여 함수형 컴포넌트를 강화

## ⚙️ 대표 Hook들

| 종류 | Hook |
|------|------|
| 상태 관리 | `useState`, `useReducer` |
| 참조 | `useRef`, `useImperativeHandle` |
| 효과 처리 | `useEffect`, `useLayoutEffect`, `useInsertionEffect` |
| 성능 최적화 | `useMemo`, `useCallback`, `useTransition`, `useDeferredValue` |
| 기타 | `useId`, `useDebugValue`, `useSyncExternalStore` |
| 사용자 정의 | Custom Hook |

## ✅ Hook 사용 규칙

- **최상위**에서만 호출 (조건문, 반복문 ❌)
- **React 함수 컴포넌트** 또는 **Custom Hook** 안에서만 호출

## 🧠 useState 기본

```js
const [state, setState] = useState(initialValue)
```

- 상태 값을 선언하고 수정 가능
- `setState`는 렌더링을 트리거함

### 예제

```js
const [count, setCount] = useState(0);

function increment() {
  setCount(count + 1);
}
```

### 이전 상태 기준 업데이트 (💡주의사항)

```js
setCount(prev => prev + 1); // 안전하게 여러 번 호출 가능
```

## 📝 객체 & 배열 상태 업데이트

- 기존 객체/배열을 직접 수정 ❌  
- 항상 **새로운 객체/배열**을 만들어야 함

```js
setForm({ ...form, name: 'Taylor' });
setTodos([...todos, newTodo]);
```

## 🧪 주의사항 (Troubleshooting)

- 상태 변경 후 즉시 값 반영 ❌ → 다음 렌더링에 적용됨
- `setState(someFunction)` 시 함수 실행됨 → `() => someFunction`으로 감싸야 저장됨
- Strict Mode에서는 초기화 함수와 updater 함수가 **2번 실행됨**

## 📌 활용 예시

- **Form 관리**, **Checkbox 상태**, **Todo 리스트 관리**, **객체/배열 중첩 업데이트**
- `useImmer`로 복잡한 상태 관리 간단화 가능

---
## 7주차
#### 7.1 클릭
![image](https://github.com/user-attachments/assets/528fd5fb-8039-417f-8275-9020a8c5654e)
#### 7.2 useEffect
![image](https://github.com/user-attachments/assets/7e46b942-0433-41a5-adfb-6f90cb5abb52)
#### 7.3 카운트
![image](https://github.com/user-attachments/assets/451e71cc-9ad9-48e7-8729-1848d0c052d8)
#### 7.4 타이머
![image](https://github.com/user-attachments/assets/947a7a0b-bf60-47fe-9973-b0087c7e8b48)
#### 7.5 마우스
![image](https://github.com/user-attachments/assets/1b668468-6c4d-45ed-a781-97ced502b938)
#### 7.6 api 데이터
![image](https://github.com/user-attachments/assets/46bab71f-978c-4cc4-9d26-e13f5793918b)
#### 7.7 수용 인원
![image](https://github.com/user-attachments/assets/9ee82388-4e01-48f7-af6c-e3c46186c802)
#### 7.8 usememo 없이 계산
![image](https://github.com/user-attachments/assets/772b34cf-be63-4e76-8960-bdccb0586819)
#### 7.9 usememo로 객체 메모이제이션
![image](https://github.com/user-attachments/assets/f971c273-0cc8-4184-bf94-db062dbc3f00)
#### 7.10 useCallback
![image](https://github.com/user-attachments/assets/5554690f-3aa4-4ed4-91c9-0f3378160d66)
#### 7.11 useref
![image](https://github.com/user-attachments/assets/a140958c-f11b-4ff3-b1cb-5c9b4adc901a)

---

## 7주차 수업 내용 정리

---

## 📌 Hooks 개요

React Hooks는 함수형 컴포넌트에 강력한 기능을 제공하는 혁신적인 API입니다.

> **"Hook은 특정 위치에 원하는 함수가 실행되도록 갈고리를 걸어두는 것"**

### ✨ 주요 특징

- **클래스 없이** React의 모든 기능 활용 가능
- 함수형 컴포넌트에서 **상태(state)와 생명주기(lifecycle)** 관리
- 코드의 **간결함**과 **재사용성** 향상
- 모든 Hook은 **'use'로 시작**하는 이름 사용

---

## 🧰 주요 Hook 정리

### 1️⃣ useState

```jsx
const [state, setState] = useState(initialValue);
```

#### 🎯 목적
함수형 컴포넌트에서 상태를 관리하기 위한 Hook

#### ✅ 특징
- 상태값과 상태 변경 함수를 배열 형태로 반환
- 상태 변경 시 컴포넌트 리렌더링 발생
- 변수마다 별도의 `set` 함수 존재

#### 📝 사용 예시
```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>총 {count} 번 클릭했습니다.</p>
      <button onClick={() => setCount(count + 1)}>
        클릭
      </button>
    </div>
  );
}
```

---

### 2️⃣ useEffect

```jsx
useEffect(setup, dependencies?);
```

#### 🎯 목적
부수 효과(side effect) 처리를 위한 Hook

#### ✅ 특징
- 컴포넌트 렌더링 후 실행
- 의존성 배열로 실행 시점 제어
- 정리(cleanup) 함수 반환 가능

#### 📊 실행 패턴

| 의존성 배열 | 실행 시점 |
|------------|---------|
| 없음 | 매 렌더링마다 실행 |
| `[]` | 마운트/언마운트 시 한 번만 |
| `[value]` | `value` 변경 시 실행 |

#### 📝 사용 예시

```jsx
// 마운트 시 한 번만 실행
useEffect(() => {
  console.log("컴포넌트가 마운트됨!");
}, []);

// count 변경 시마다 실행
useEffect(() => {
  console.log(`카운트 값이 변경됨: ${count}`);
  document.title = `You clicked ${count} times`;
}, [count]);

// 정리(cleanup) 함수 사용
useEffect(() => {
  const interval = setInterval(() => {
    console.log("1초마다 실행");
  }, 1000);
  
  // 컴포넌트 언마운트 또는 의존성 변경 전 실행
  return () => {
    console.log("타이머 정리");
    clearInterval(interval);
  };
}, []);
```

---

### 3️⃣ useMemo

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

#### 🎯 목적
계산 결과 메모이제이션을 통한 성능 최적화

#### ✅ 특징
- 의존성 배열 값이 변경될 때만 계산 함수 실행
- 변경이 없으면 이전 결과 재사용
- 렌더링 중에만 실행됨

#### 🔍 사용 케이스
- 비용이 큰 계산 최적화
- 객체/배열의 불필요한 재생성 방지
- 참조 동일성 유지 필요 시

#### 📝 사용 예시

```jsx
function App() {
  const [count, setCount] = useState(0);
  const [number, setNumber] = useState(1);
  
  // number가 변경될 때만 계산 실행
  const expensiveResult = useMemo(() => {
    console.log("계산 중...");
    let result = 0;
    for (let i = 0; i < 100000000; i++) {
      result += number;
    }
    return result;
  }, [number]);
  
  return (
    <div>
      <h1>useMemo를 사용하여 최적화</h1>
      <button onClick={() => setCount(count + 1)}>
        클릭: {count}
      </button>
      <h2>결과: {expensiveResult}</h2>
    </div>
  );
}
```

---

### 4️⃣ useCallback

```jsx
const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);
```

#### 🎯 목적
함수 메모이제이션을 통한 성능 최적화

#### ✅ 특징
- 의존성 배열 값이 변경될 때만 함수 재생성
- 자식 컴포넌트에 props로 전달하는 콜백 함수에 유용
- 불필요한 렌더링 방지

#### 📊 useMemo vs useCallback

| Hook | 메모이제이션 대상 |
|------|-----------------|
| useMemo | 계산된 값 |
| useCallback | 함수 자체 |

#### 📝 사용 예시

```jsx
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // count가 변경되어도 handleClick은 재생성되지 않음
  const handleClick = useCallback(() => {
    console.log("버튼 클릭됨");
  }, []); // 의존성 배열이 비어 있음
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        카운트 증가
      </button>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}
```

---

### 5️⃣ useRef

```jsx
const ref = useRef(initialValue);
```

#### 🎯 목적
- DOM 요소에 직접 접근
- 리렌더링 없이 값 저장

#### ✅ 특징
- `.current` 속성을 통해 현재 값 접근
- 값 변경해도 리렌더링 발생하지 않음
- 컴포넌트 생명주기 동안 유지됨

#### 🔍 주요 사용 사례
1. DOM 요소 참조
2. 이전 값 저장
3. 인스턴스 변수 (클래스의 this와 유사)

#### 📝 사용 예시

```jsx
// 1. DOM 접근
function InputFocus() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    // 렌더링 후 input에 포커스
    inputRef.current.focus();
  }, []);
  
  return <input ref={inputRef} type="text" />;
}

// 2. 값 저장 (리렌더링 없이)
function Counter() {
  const countRef = useRef(0);
  const [renderCount, setRenderCount] = useState(0);
  
  const increment = () => {
    countRef.current += 1; // 리렌더링 발생 안 함
    console.log("Ref 값:", countRef.current);
  };
  
  return (
    <div>
      <p>렌더링 횟수: {renderCount}</p>
      <button onClick={() => setRenderCount(renderCount + 1)}>
        렌더 트리거
      </button>
      <button onClick={increment}>Ref 증가</button>
    </div>
  );
}
```

---

## 🛠️ Custom Hook

자신만의 Hook을 만들어 로직을 재사용할 수 있습니다.

### ✅ 특징
- `use`로 시작하는 이름 사용
- 내부에서 다른 Hook 호출 가능
- 컴포넌트 로직 분리 및 재사용성 향상

### 📝 예시 - 카운터 Custom Hook

```jsx
// useCounter.js
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(Math.max(0, count - 1));
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// 사용 예시
function CounterComponent() {
  const { count, increment, decrement, reset } = useCounter(10);
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

### 📝 예시 - API 데이터 가져오기 Hook

```jsx
// useFetch.js
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then((response) => response.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);
  
  return { data, loading, error };
}

// 사용 예시
function Users() {
  const { data, loading, error } = useFetch("https://jsonplaceholder.typicode.com/users");
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  
  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## ⚠️ Hook 사용 규칙

### 1. 최상위 레벨에서만 호출
- ❌ 조건문, 반복문, 중첩 함수 내에서 Hook 호출 금지
- ✅ 항상 같은 순서로 호출되어야 함

```jsx
// ❌ 잘못된 사용
function MyComponent() {
  const [name, setName] = useState('React');
  
  if (name !== '') {
    useEffect(() => {
      // ...
    });
  }
  // ...
}

// ✅ 올바른 사용
function MyComponent() {
  const [name, setName] = useState('React');
  
  useEffect(() => {
    if (name !== '') {
      // ...
    }
  }, [name]);
  // ...
}
```

### 2. React 함수 컴포넌트 내에서만 사용
- ❌ 일반 JavaScript 함수에서 사용 금지
- ✅ 함수 컴포넌트 또는 Custom Hook에서만 사용

---

## 🔧 추천 개발 도구

### 플러그인 및 확장 프로그램
- 🛠️ ES7+ React/Redux/React-Native snippets
- 🔍 React Developer Tools (Chrome 확장)
- 📝 JavaScript (ES6) Code Snippets
- 🧹 ESLint
- 💅 Prettier - Code formatter
- 🎨 Bracket Pair Colorizer

### 유용한 React 라이브러리
- **UI**: Material-UI, Ant Design, Chakra UI
- **상태 관리**: Redux, MobX, Recoil, Zustand
- **라우팅**: React Router
- **폼 관리**: Formik, React Hook Form
- **데이터 Fetching**: Axios, React Query
- **애니메이션**: Framer Motion, React Spring

---

## 🎓 마무리

React Hooks는 함수형 컴포넌트의 한계를 극복하고 더 직관적이고 재사용 가능한 코드를 작성할 수 있게 해줍니다. 각 Hook의 목적과 사용법을 정확히 이해하면 더 효율적인 React 애플리케이션을 개발할 수 있습니다.

> **"Hook을 사용하면 클래스형 컴포넌트 없이도 React의 모든 기능을 활용할 수 있습니다."**

---
## 9주차
#### 9.1 실행 결과 
![image](https://github.com/user-attachments/assets/f5634854-85e8-4e45-a2d0-f5e55bcc43c8)
#### 9.2 
![image](https://github.com/user-attachments/assets/88402018-ffed-494d-b9ae-d68343462e3a)
#### 9.3
![image](https://github.com/user-attachments/assets/19035b3a-989e-4fe1-86b9-af63eb43f4ca)
#### 9.4
![image](https://github.com/user-attachments/assets/c20d116e-a661-4b7a-8e63-1ca4b5356e7c)
#### 9.5
![image](https://github.com/user-attachments/assets/d18229f8-21b8-40d6-8269-5017a367ad73)
#### 9.6
![image](https://github.com/user-attachments/assets/4e392754-4aa1-409d-988f-916e84eb9bac)
#### 9.7
![image](https://github.com/user-attachments/assets/4ed2df1b-9b66-4fa6-ae28-bfcfac8ad6b6)

---

# 📚 9주차 수업 정리 (React)

## 1️⃣ 리액트 이벤트 핸들러 

### 📌 이벤트란?
- 사용자 입력(클릭, 입력 등)에 반응하여 동작을 수행하는 것
- 이벤트를 처리하는 함수 = **이벤트 핸들러**

### 🧩 React vs DOM 이벤트
| 항목 | DOM 이벤트 | React 이벤트 |
|------|------------|--------------|
| 등록 방식 | `addEventListener` | `onClick={}` 등 |
| 네이밍 | 소문자(`onclick`) | 카멜케이스(`onClick`) |
| 제거 방식 | 수동 제거 | 자동 제거 (언마운트 시) |
| 이벤트 객체 | `Event` | `SyntheticEvent` |

### 🛠 주요 개념
- **기본 사용법**:
  ```jsx
  <button onClick={handleClick}>클릭</button>
  ```
- **이벤트 객체 활용**: `event.target.value`
- **상태 변경과 연동**:
  ```jsx
  const [count, setCount] = useState(0);
  const handleClick = () => setCount(count + 1);
  ```
- **이벤트 전달 방지**: `event.stopPropagation()`
- **기본 동작 방지**: `event.preventDefault()`
- **useCallback 최적화**: 불필요한 함수 재생성 방지
- **인자 전달**:
  ```jsx
  <button onClick={() => handleClick("홍길동")}>클릭</button>
  ```

---

## 2️⃣ 조건부 렌더링 

### 📌 정의
- 조건에 따라 **화면에 표시할 UI를 동적으로 바꾸는 방법**

### ✅ 사용 가능한 조건부 렌더링 방법
| 방식 | 사용 예 |
|------|---------|
| `if`문 | 명확한 조건 분기 |
| 삼항 연산자 (`? :`) | `{isLogin ? A : B}` |
| `&&` 연산자 | `{isLogin && A}` |
| `??` 연산자 | `user ?? "Guest"` |
| 즉시 실행 함수 (IIFE) | `{(() => {})()}` |
| `switch` 문 | 여러 조건 처리 |
| 컴포넌트 분리 | `<Login />` or `<Logout />` |

### 🧩 Truthy / Falsy 개념
- Falsy: `false`, `0`, `""`, `null`, `undefined`, `NaN`
- Truthy: 비어있지 않은 값들, 배열/객체 등

### 💻 예제
```jsx
function Greeting({ isLoggedIn }) {
  return <h1>{isLoggedIn ? "환영합니다!" : "로그인이 필요합니다."}</h1>;
}
```

### 🛠 실습 예시
- 로그인 버튼을 눌렀을 때 텍스트 변경
- `Toolbar.jsx` / `LandingPage.jsx`로 상태 전달

---

## ✅ 요약 비교표

| 주제 | 핵심 내용 |
|------|-----------|
| 이벤트 처리 | `onClick`, `onChange`, SyntheticEvent 사용 |
| 상태 변경 | `useState` + 이벤트 핸들러에서 상태 변경 |
| 최적화 | `useCallback`으로 함수 재생성 방지 |
| 조건부 렌더링 | `if`, 삼항 연산자, `&&`, `??`, 컴포넌트 분리 |

---

## 11주차
#### 11.1 출석부
![image](https://github.com/user-attachments/assets/c637a0dc-05e0-417d-b3aa-f2256c163ea3)
#### 11.2 SignUp
![image](https://github.com/user-attachments/assets/1c46fc61-bba1-4e67-a8f9-78626dbfa927)
#### 11.3 온도
![image](https://github.com/user-attachments/assets/0500cd85-5f7d-4613-a402-8a7367975acb)
#### 11.4 프로필
![image](https://github.com/user-attachments/assets/3eecf977-7fbb-43e5-978a-2961a5f14209)

# 11주차 수업 정리

## Lists & Keys

리액트에서 배열 형태의 데이터를 효율적으로 렌더링하고 각 컴포넌트를 고유하게 식별하기 위한 핵심 개념입니다.

### map() 함수

- JavaScript 배열의 메서드로, 각 요소를 변환하여 새로운 배열을 생성합니다
- 원본 배열을 변경하지 않고, 새로운 배열을 반환합니다
- React에서 리스트를 동적으로 렌더링할 때 필수적으로 사용됩니다

```javascript
// 기본 사용법
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 객체 배열 반환
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' },
];
const userNames = users.map(user => user.name);
console.log(userNames); // ['Alice', 'Bob', 'Charlie']

// 리액트에서의 사용
const items = ['Apple', 'Banana', 'Cherry'];
function ItemList() {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

### Key의 중요성

- 리액트에서 리스트를 렌더링할 때 각 항목에는 고유한 "key" 속성이 필요합니다
- key는 리액트가 어떤 항목이 변경, 추가, 제거되었는지 식별하는 데 사용됩니다
- 효율적인 리스트 업데이트를 위해 매우 중요합니다

```javascript
// 인덱스를 key로 사용 (비추천)
function NameList() {
  const names = ["Alice", "Bob", "Charlie"];
  return (
    <ul>
      {names.map((name, index) => (
        <li key={index}>{name}</li>
      ))}
    </ul>
  );
}

// ID를 key로 사용 (추천)
function UserList() {
  const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
  ];
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Forms

사용자 입력을 처리하고 데이터를 서버로 전송하기 위한 요소입니다.

### Controlled Components

- 값이 React의 상태에 의해 제어되는 폼 요소입니다
- HTML 폼과 달리 React 상태가 "단일 진실 공급원(Single Source of Truth)"이 됩니다

```javascript
function NameForm(props) {
  const [value, setValue] = useState('');
  
  const handleChange = (event) => {
    setValue(event.target.value);
  }
  
  const handleSubmit = (event) => {
    alert('입력한 이름: ' + value);
    event.preventDefault();
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <label>
        이름:
        <input type="text" value={value} onChange={handleChange} />
      </label>
      <button type="submit">제출</button>
    </form>
  );
}
```

### 다양한 폼 요소 다루기

- `input`, `textarea`, `select` 등의 요소를 유사한 방식으로 처리할 수 있습니다
- 여러 입력 필드는 객체 상태를 사용하여 효율적으로 관리할 수 있습니다

```javascript
function MultiInputForm() {
  const [formData, setFormData] = useState({ name: "", email: "" });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="name" value={formData.name} onChange={handleChange} />
      <input type="email" name="email" value={formData.email} onChange={handleChange} />
      <button type="submit">제출</button>
    </form>
  );
}
```

## Lifting State Up (상태 끌어올리기)

- 여러 컴포넌트가 동일한 데이터를 공유해야 할 때 사용하는 패턴입니다
- 상태를 공통 부모 컴포넌트로 끌어올려 중앙에서 관리합니다

### 구현 단계:

1. 공유할 상태를 부모 컴포넌트에 정의
2. 상태 변경 함수를 자식 컴포넌트에 props로 전달
3. 자식 컴포넌트에서 props로 받은 함수를 사용해 부모의 상태 변경
4. 변경된 상태를 props를 통해 다시 자식에게 전달

```javascript
function Parent() {
  const [text, setText] = useState("");
  
  return (
    <div>
      <ChildA text={text} setText={setText} />
      <ChildB text={text} />
    </div>
  );
}

function ChildA({ text, setText }) {
  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
}

function ChildB({ text }) {
  return <p>ChildA에서 입력한 값: {text}</p>;
}
```

## Composition vs Inheritance

리액트에서는 상속(Inheritance)보다 합성(Composition)을 통한 컴포넌트 재사용을 권장합니다.

### 합성(Composition)의 방식:

1. **Containment (포함)**: `children` props를 사용하여 컴포넌트 내에 다른 컴포넌트를 포함

```javascript
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

function App() {
  return (
    <Card>
      <h2>제목</h2>
      <p>내용입니다</p>
    </Card>
  );
}
```

2. **Specialization (특수화)**: 특정 목적을 위해 일반 컴포넌트를 구체화

```javascript
function Dialog({ title, message }) {
  return (
    <div className="dialog">
      <h3>{title}</h3>
      <p>{message}</p>
    </div>
  );
}

function WarningDialog() {
  return <Dialog title="경고!" message="이 작업은 취소할 수 없습니다." />;
}
```

3. **Higher-Order Components (HOC)**: 컴포넌트를 감싸 기능을 확장하는 패턴

```javascript
function withLogger(WrappedComponent) {
  return function(props) {
    console.log("렌더링:", WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

const EnhancedComponent = withLogger(MyComponent);
```
## 12주차

### TODO list 만들기
#### 페이지에 회색 배경색상 적용
![image](https://github.com/user-attachments/assets/fe3810f3-059b-4672-9b64-b27ed9ea8c46)

#### TodoTemplate
 투두리스트의 레이아웃을 설정하는 컴포넌트. 페이지의 중앙에 그림자가 적용된 흰색 박스를 보여준다.
![image](https://github.com/user-attachments/assets/5c10f8f7-ba5a-4d38-aae9-b7a9f111577e)

#### TodoHead
 오늘의 날짜와 요일을 보여주고, 앞으로 해야 할 일이 몇개 남았는지 보여준다.
![image](https://github.com/user-attachments/assets/6fba162a-2cca-420e-9ba7-25c9a6d54299)

#### TodoList
 할 일에 대한 정보가 들어있는 todos 배열을 내장함수 map을 사용하여 여러 개의 TodoItem 컴포넌트를
렌더링해준다.
![image](https://github.com/user-attachments/assets/a8987d2e-7a5f-475b-8bcb-f2355123676f)

#### TodoItem
 각 할 일에 대한 정보를 렌더링해주는 컴포넌트. 좌측에 있는 원을 누르면 할 일의 완료 여부를 toggle 할
수 있다. 할 일이 완료됐을 땐 좌측에 체크가 나타나고 텍스트의 색상이 연해진다. 그리고, 마우스를 올리
면 휴지통 아이콘이 나타나고 이를 누르면 항목이 삭제된다.
![image](https://github.com/user-attachments/assets/431f4dd4-6e85-4389-bc05-4005bf51cf2f)

#### TodoCreate
• 새로운 할 일을 등록할 수 있게 해주는 컴포넌트. TodoTemplate 의 하단부에 초록색 원 버튼을 렌더링해
주고, 이를 클릭하면 할 일을 입력 할 수 있는 폼이 나타난다. 버튼을 다시 누르면 폼이 사라진다.
![image](https://github.com/user-attachments/assets/c2b809c0-7e2f-4448-af56-0659475bde12)



## 📝 Web Programming 12주차 수업 내용 정리

> React TODO List 앱 만들기 (1-17장)  

## 📚 학습 목표
- React와 styled-components를 활용한 실제 프로젝트 구현
- 컴포넌트 기반 UI 설계 및 구현
- CSS-in-JS 라이브러리 활용법 학습

## 🛠 개발 환경 설정

### 프로젝트 생성 및 패키지 설치
```bash
npx create-react-app mashup-todolist
cd mashup-todolist
yarn add react-icons styled-components
```

### 사용 기술 스택
- **React**: 컴포넌트 기반 UI 라이브러리
- **styled-components**: CSS-in-JS 스타일링
- **react-icons**: 아이콘 라이브러리

## 🏗 프로젝트 구조 설계

### 컴포넌트 계획
```
TodoTemplate (레이아웃)
├── TodoHead (헤더)
├── TodoList (리스트)
│   └── TodoItem (개별 아이템)
└── TodoCreate (입력 폼)
```

### 각 컴포넌트 역할

| 컴포넌트 | 역할 | 주요 기능 |
|---------|------|-----------|
| `TodoTemplate` | 전체 레이아웃 | 중앙 정렬, 그림자 효과 |
| `TodoHead` | 헤더 영역 | 날짜, 요일, 남은 할 일 개수 |
| `TodoList` | 리스트 컨테이너 | TodoItem들을 map으로 렌더링 |
| `TodoItem` | 개별 할 일 | 완료 토글, 삭제 기능 |
| `TodoCreate` | 입력 폼 | 새 할 일 추가, 토글 UI |

## 💄 스타일링 구현

### 1. 전역 스타일 설정
```javascript
import { createGlobalStyle } from 'styled-components';

const GlobalStyle = createGlobalStyle`
  body {
    background: #e9ecef;
  }
`;
```

### 2. TodoTemplate - 메인 레이아웃
```javascript
const TodoTemplateBlock = styled.div`
  width: 512px;
  height: 768px;
  position: relative;
  background: white;
  border-radius: 16px;
  box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.04);
  margin: 0 auto;
  margin-top: 96px;
  margin-bottom: 32px;
  display: flex;
  flex-direction: column;
`;
```

### 3. TodoHead - 헤더 스타일링
```javascript
const TodoHeadBlock = styled.div`
  padding: 48px 32px 24px 32px;
  border-bottom: 1px solid #e9ecef;
  
  h1 {
    margin: 0;
    font-size: 36px;
    color: #343a40;
  }
  
  .day {
    margin-top: 4px;
    color: #868e96;
    font-size: 21px;
  }
  
  .tasks-left {
    color: #20c997;
    font-size: 18px;
    margin-top: 40px;
    font-weight: bold;
  }
`;
```

### 4. TodoList - 스크롤 가능한 리스트
```javascript
const TodoListBlock = styled.div`
  flex: 1;  /* 남은 공간 모두 차지 */
  padding: 20px 32px;
  padding-bottom: 48px;
  overflow-y: auto;  /* 스크롤 허용 */
`;
```

### 5. TodoItem - 개별 아이템 스타일링

#### Component Selector 활용
```javascript
const Remove = styled.div`
  display: none;  /* 기본적으로 숨김 */
  /* 스타일링... */
`;

const TodoItemBlock = styled.div`
  display: flex;
  align-items: center;
  
  &:hover {
    ${Remove} {
      display: initial;  /* 호버 시 삭제 버튼 표시 */
    }
  }
`;
```

#### 조건부 스타일링
```javascript
const CheckCircle = styled.div`
  width: 32px;
  height: 32px;
  border-radius: 16px;
  border: 1px solid #ced4da;
  
  ${props =>
    props.done &&
    css`
      border: 1px solid #38d9a9;
      color: #38d9a9;
    `}
`;
```

### 6. TodoCreate - 플로팅 버튼과 입력 폼

#### 플로팅 버튼
```javascript
const CircleButton = styled.button`
  background: #38d9a9;
  width: 80px;
  height: 80px;
  position: absolute;
  left: 50%;
  bottom: 0px;
  transform: translate(-50%, 50%);
  border-radius: 50%;
  transition: 0.125s all ease-in;
  
  ${props =>
    props.open &&
    css`
      background: #ff6b6b;
      transform: translate(-50%, 50%) rotate(45deg);  /* 45도 회전 */
    `}
`;
```

## 🧩 컴포넌트 구현

### App.js - 최상위 컴포넌트
```javascript
function App() {
  return (
    <>
      <GlobalStyle />
      <TodoTemplate>
        <TodoHead />
        <TodoList />
        <TodoCreate />
      </TodoTemplate>
    </>
  );
}
```

### TodoCreate - 상태 관리
```javascript
function TodoCreate() {
  const [open, setOpen] = useState(false);
  const onToggle = () => setOpen(!open);
  
  return (
    <>
      {open && (
        <InsertFormPositioner>
          <InsertForm>
            <Input 
              autoFocus 
              placeholder="할 일을 입력 후, Enter 를 누르세요" 
            />
          </InsertForm>
        </InsertFormPositioner>
      )}
      <CircleButton onClick={onToggle} open={open}>
        <MdAdd />
      </CircleButton>
    </>
  );
}
```

## 🎯 구현된 주요 기능

### ✅ 완료된 기능 (17장까지)
- [x] 프로젝트 초기 설정
- [x] 전체 UI 컴포넌트 구현
- [x] styled-components 스타일링
- [x] 반응형 레이아웃 (flex)
- [x] 호버 효과 및 애니메이션
- [x] TodoCreate 토글 기능

### 🔄 애니메이션 효과
1. **버튼 회전**: Add 버튼 클릭 시 45도 회전
2. **색상 변화**: 녹색 → 빨간색 전환
3. **호버 효과**: TodoItem 호버 시 삭제 버튼 표시
4. **부드러운 전환**: `transition: 0.125s all ease-in`

## 📁 파일 구조
```
src/
├── components/
│   ├── TodoTemplate.js    # 메인 레이아웃
│   ├── TodoHead.js        # 헤더 (날짜, 할일 개수)
│   ├── TodoList.js        # 할일 리스트 컨테이너
│   ├── TodoItem.js        # 개별 할일 아이템
│   └── TodoCreate.js      # 할일 추가 폼
├── App.js                 # 루트 컴포넌트
└── index.js              # 앱 진입점
```

## 🔍 주요 학습 포인트

### 1. styled-components 고급 기능
- **createGlobalStyle**: 전역 스타일 적용
- **Component Selector**: 부모-자식 관계 스타일링
- **조건부 스타일링**: props 기반 동적 스타일

### 2. CSS 레이아웃 기법
- **Flexbox**: 유연한 레이아웃 구성
- **Position absolute**: 플로팅 버튼 배치
- **Transform**: 중앙 정렬 및 회전 효과

### 3. 사용자 경험 (UX) 개선
- **직관적인 아이콘 사용**: react-icons 활용
- **시각적 피드백**: 호버, 클릭 효과
- **부드러운 애니메이션**: transition 활용

## 🚀 다음 단계 (18장 이후 예정)
- Context API를 활용한 상태 관리
- useReducer로 복잡한 상태 로직 처리
- 실제 CRUD 기능 구현
- 성능 최적화 (React.memo)



























